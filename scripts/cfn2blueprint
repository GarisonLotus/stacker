#!/usr/bin/env python
"""
This cfn2blueprint script originally sourced, but heavily modified from cfn2py
in the troposphere repo from commit 933e6565b2a8330dd8100470002c7f3b520bf0d5.

Thanks for everyone who chipped in to cfn2py and troposphere!


This script will convert your existing CFN template in JSON to
a stacker blueprint.

Run like so: cfn2blueprint ./sturdycore.json ./sturdycore.py



We recomend running stacker diff or build with interactive mode on the first
time to ensure the blueprint was corectly generated.

"""
import argparse
import json


class object_registry(object):
    """Keep track of objects being created as Parameters or Resources
    in order to map back to due to use in intrinsic functions like
    Ref() and GetAtt().
    """
    global CONDITIONSPRESENT
    CONDITIONSPRESENT = 0
    global AWSTEMPLATEFORMATVERSIONPRESENT
    AWSTEMPLATEFORMATVERSIONPRESENT = 0
    global DESCRIPTIONPRESENT
    DESCRIPTIONPRESENT = 0
    global MAPPINGSPRESENT
    MAPPINGSPRESENT = 0
    global OUTPUTSPRESENT
    OUTPUTSPRESENT = 0
    global PARAMETERSPRESENT
    PARAMETERSPRESENT = 0
    global PARAMS
    PARAMS = []
    """ this above PARAMS global list is used later to determine if a Ref is a
     Ref to a CFN paramter or if it's a Ref to another Python object """

    def __init__(self):
        self.objects = {}

    def add(self, o):
        new_name = o.replace('-', '_')
        self.objects[o] = new_name
        return new_name

    def lookup(self, o):
        if o in self.objects:
            return self.objects[o]
        else:
            return output_value(o)

objects = object_registry()

object_functions = {
    "Table":        [ "ProvisionedThroughput", "PrimaryKey", "Element" ],
    "LoadBalancer": [ "HealthCheck", "ConnectionDrainingPolicy", "AccessLoggingPolicy" ],
    "Queue":        [ "RedrivePolicy" ],
    "Bucket":       [ "WebsiteConfiguration" ],
    "User":         [ "LoginProfile" ],
    "Topic":        [ "Subscription" ],
    "Instance":     [ "NetworkInterfaceProperty", "PrivateIpAddressSpecification" ],
    "RecordSet":    [ "RecordSetType" ],
    "Policy":       [ "PolicyType" ],
}

def additional_imports(o):
    if object_functions.has_key(o):
        return ", ".join([o] + object_functions[o])
    else:
        return o

""" generating the blueprint header """
def do_header(d):
    """Output a stock header for the new Python script and also try to
    figure out the Resource imports needed by the template.
    """
    blueprint.write('from troposphere import (\n')
    blueprint.write('    Base64, Select, FindInMap, GetAtt, GetAZs, Join,\n')
    blueprint.write('    Output, If, And, Not, Or, Equals, Condition\n)\n')
    blueprint.write('from troposphere import Parameter, Ref, Tags, Template\n')
    blueprint.write('from troposphere.cloudformation import Init\n')
    blueprint.write('from troposphere.cloudfront import (\n')
    blueprint.write('    Distribution, DistributionConfig, Origin,\n')
    blueprint.write('    DefaultCacheBehavior\n)\n')
    blueprint.write('from troposphere.ec2 import PortRange\n')
    blueprint.write('from stacker.blueprints.variables.types import (\n')
    blueprint.write('    CFNString, CFNNumber, CFNNumberList,\n')
    blueprint.write('    CFNCommaDelimitedList, EC2AvailabilityZoneName,\n')
    blueprint.write('    EC2ImageId, EC2ImageId, EC2InstanceId,\n')
    blueprint.write('    EC2KeyPairKeyName, EC2SecurityGroupGroupName,\n')
    blueprint.write('    EC2SecurityGroupId, EC2SubnetId, EC2VolumeId,\n')
    blueprint.write('    EC2VPCId, Route53HostedZoneId,\n')
    blueprint.write('    EC2AvailabilityZoneNameList, EC2ImageIdList,\n')
    blueprint.write('    EC2InstanceIdList, EC2SecurityGroupGroupNameList,\n')
    blueprint.write('    EC2SecurityGroupIdList, EC2SubnetIdList,\n')
    blueprint.write('    EC2VolumeIdList, EC2VPCIdList,\n')
    blueprint.write('    Route53HostedZoneIdList,\n')
    blueprint.write(')\n')

    """ Loop over the resources to find imports """
    if 'Resources' in d:
        seen = []
        resources = d['Resources']
        for k, v in resources.items():
            (mod, tropo_object) = generate_troposphere_object(v['Type'])
            if tropo_object not in seen:
                seen.append(tropo_object)
                blueprint.write('from troposphere.%s import %s\n' % (
                                mod, additional_imports(tropo_object)))
    blueprint.write('from stacker.blueprints.base import Blueprint\n')
    blueprint.write('\n')
    blueprint.write('\n')

def do_classdefinition(d):
    """Output the Class"""
    CLASSNAME = args.blueprint.replace(".py", "")
    CLASSNAME = CLASSNAME.replace(".", "")
    CLASSNAME = CLASSNAME.replace("/", "")
    CLASSNAME = CLASSNAME.replace("-", "")
    blueprint.write('class %s(Blueprint):\n' % (CLASSNAME))
    blueprint.write('    """\n    cfn2blueprint generated blueprint converted '
                    'from cloudformation into a stacker blueprint\n\n    The '
                    'Class name would be called in your class path in the '
                    'stacker config. In the class itself are\n    functions '
                    'that are added when dectected in your source CFN '
                    'template.\n\n\n    Each function is called by the '
                    'create_template function at the bottem of this ')
    blueprint.write('blueprint\n\n\n\n    We recomend running stacker diff ')
    blueprint.write('or build with interactive mode on the first time to \n ')
    blueprint.write('   ensure the blueprint was corectly generated.    """\n')
    blueprint.write('\n')

def do_awstemplateformatversion(d):
    """Output the template version"""
    global AWSTEMPLATEFORMATVERSIONPRESENT
    AWSTEMPLATEFORMATVERSIONPRESENT = 1
    blueprint.write('    def add_cfn_version(self):\n')
    blueprint.write('        t = self.template\n')
    blueprint.write('        t.add_version("%s")\n' % (
        d['AWSTemplateFormatVersion'], ))
    blueprint.write('\n')
    blueprint.write('\n')


def do_description(d):
    """Output the template Description"""
    global DESCRIPTIONPRESENT
    DESCRIPTIONPRESENT = 1
    blueprint.write('    def add_cfn_description(self):\n')
    blueprint.write('        t = self.template\n')
    blueprint.write('        t.add_description(\n            "'
                    '%s"\n        )\n' % (d['Description'], ))
    blueprint.write('\n')
    blueprint.write('\n')


def do_parameters(d):

    params_to_varibles = {
        "String": "CFNString",
        "Number": "CFNNumber",
        "List<Number>": "CFNNumberList",
        "CommaDelimitedList": "CFNCommaDelimitedList",
        "AWS::EC2::AvailabilityZone::Name": "EC2AvailabilityZoneName",
        "AWS::EC2::Image::Id": "EC2ImageId",
        "AWS::EC2::Instance::Id": "EC2InstanceId",
        "AWS::EC2::KeyPair::KeyName": "EC2KeyPairKeyName",
        "AWS::EC2::SecurityGroup::GroupName": "EC2SecurityGroupGroupName",
        "AWS::EC2::SecurityGroup::Id": "EC2SecurityGroupId",
        "AWS::EC2::Subnet::Id": "EC2SubnetId",
        "AWS::EC2::Volume::Id": "EC2VolumeId",
        "AWS::EC2::VPC::Id": "EC2VPCId",
        "AWS::Route53::HostedZone::Id": "Route53HostedZoneId",
        "List<AWS::EC2::AvailabilityZone::Name>":
            "EC2AvailabilityZoneNameList",
        "List<AWS::EC2::Image::Id>": "EC2ImageIdList",
        "List<AWS::EC2::Instance::Id>": "EC2InstanceIdList",
        "List<AWS::EC2::SecurityGroup::GroupName>":
            "EC2SecurityGroupGroupNameList",
        "List<AWS::EC2::SecurityGroup::Id>": "EC2SecurityGroupIdList",
        "List<AWS::EC2::Subnet::Id>": "EC2SubnetIdList",
        "List<AWS::EC2::Volume::Id>": "EC2VolumeIdList",
        "List<AWS::EC2::VPC::Id>": "EC2VPCIdList",
        "List<AWS::Route53::HostedZone::Id>": "Route53HostedZoneIdList",
    }

    """Output the template Parameters as stacker Varibles"""
    global PARAMETERSPRESENT
    PARAMETERSPRESENT = 1
    params = d['Parameters']
    blueprint.write('    VARIABLES = {\n')
    for k, v in params.items():
        global PARAMS
        PARAMS.append(k)
        blueprint.write('        \"%s\": {\n' % (k,))
        for vk, vv in v.items():
            if type(vv) is not list:
                if params_to_varibles.has_key(vv):
                    m = params_to_varibles[vv]
                    blueprint.write('            \"type\": \"%s\",\n' % (m))
            if vk == "Default":
                blueprint.write('            \"default\": \"%s\",\n' % (vv))
            if vk == "NoEcho":
                blueprint.write('            \"no_echo\": \"%s\",\n' % (vv))
            if vk == "Description":
                blueprint.write('            \"description\": \"%s\",\n' % (
                            vv))
            if vk == "AllowedValues":
                allowed = []
                for allowedvalue in vv:
                    allowed.append(str(allowedvalue))
                blueprint.write('            \"allowed_values\": %s,\n' % (
                    allowed))
            if vk == "AllowedPattern":
                blueprint.write('            \"allowed_pattern\": \"%s\",\n' %
                                (vv))
            if vk == "MaxLength":
                blueprint.write('            \"max_length\": \"%s\",\n' % (vv))
            if vk == "MinLength":
                blueprint.write('            \"min_length\": \"%s\",\n' % (vv))
            if vk == "MaxValue":
                blueprint.write('            \"max_value\": \"%s\",\n' % (vv))
            if vk == "MinValue":
                blueprint.write('            \"min_value\": \"%s\",\n' % (vv))
            if vk == "ConstraintDescription":
                blueprint.write('            \"constraint_description\":')
                blueprint.write(' \"%s\",\n' % (vv))
            else:
                pass
        blueprint.write('        },\n')
    blueprint.write('    }\n')
    blueprint.write('\n\n')


def do_conditions(d):
    """Output the template Conditions"""
    global CONDITIONSPRESENT
    CONDITIONSPRESENT = 1
    blueprint.write('    def add_conditions(self):\n')
    blueprint.write('        t = self.template\n')
    conditions = d['Conditions']
    for k, v in conditions.items():
        blueprint.write('        t.add_condition("%s",\n' % (k,))
        blueprint.write('            %s\n' % output_value(v))
        blueprint.write('        )\n')
        blueprint.write('\n')

def do_mappings(d):
    """Output the template Mappings"""
    global MAPPINGSPRESENT
    MAPPINGSPRESENT = 1
    blueprint.write('    """ Note: Stacker has support for mappings in the')
    blueprint.write(' yaml config\n    It\'s a good idea to move these')
    blueprint.write(' there. """\n')
    blueprint.write('    def add_mappings(self):\n')
    blueprint.write('        t = self.template\n')
    mappings = d['Mappings']
    for k, v in mappings.items():
        blueprint.write('        t.add_mapping("%s", {\n' % (k,))
        for vk, vv in v.items():
            for vvk, vvv in vv.items():
                blueprint.write('            "%s": {"%s": "%s"},\n' % (
                        vk, vvk, vvv))
        blueprint.write('        })\n')
        blueprint.write('        \n')

def map_module(mod):
    """Map module names as needed"""
    if mod == "lambda":
        return "awslambda"
    return mod


def generate_troposphere_object(typename):
    """Try to determine the troposphere object to create from the Type
    specification from the Resource being converted.
    """
    t = typename.split(':')
    if len(t) == 5:
        return (map_module(t[2].lower()), t[4])
    else:
        return ('', typename)


def output_dict(d):
    out = []
    for k,v in d.items():
        out.append("%s=%s" % (k.replace('\\', '\\\\'), output_value(v)))
    return ", ".join(out)

known_functions = {
    "DistributionConfig":       1,
    "DefaultCacheBehavior":     1,
    "ProvisionedThroughput":    1,
    "NetworkInterfaces":        1,
    "WebsiteConfiguration":     1,
    "RedrivePolicy":            1,
    "Subscription":             1,
    "KeySchema":                1,
    "HashKeyElement":           1,
    "HealthCheck":              1,
    "LoginProfile":             1,
    "ConnectionDrainingPolicy": 1,
    "AccessLoggingPolicy":      1,
    "AWS::CloudFormation::Init":1,
    "PrivateIpAddresses"       :1,
    "ContainerDefinitions"     :1,
}

function_quirks = {
    "KeySchema":          "PrimaryKey",
    "HashKeyElement":     { "Element": ["AttributeName", "AttributeType"] },
    "NetworkInterfaces":  [ "NetworkInterfaceProperty" ],
    "Subscription":       [ "Subscription" ],
    "LoginProfile":       { "LoginProfile": ["Password"] },
    "AWS::CloudFormation::Init": {"Init": []},
    "PrivateIpAddresses": ["PrivateIpAddressSpecification"],
    "ContainerDefinitions": ["ContainerDefinition"],
}

def do_output_function(k, f, v):
    blueprint.write('    %s=%s(\n' % (k, f))
    for pk, pv in v.items():
        if known_functions.has_key(pk):
            do_resources_content(pk, pv, "")
        else:
            blueprint.write('        %s=%s,\n' % (pk, output_value(pv)))
    blueprint.write('    ),\n')

def do_output_quirk_list(k, f, v):
    blueprint.write('    %s=[\n' % (k))
    for e in v:
        blueprint.write('    %s(\n' % (f))
        for pk, pv in e.items():
            if known_functions.has_key(pk):
                do_resources_content(pk, pv)
            else:
                blueprint.write('        %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('    ),\n')
    blueprint.write('    ],\n')

def do_output_quirk_mapping(k, v):
    m = function_quirks[k]
    for pk in m.keys():
        blueprint.write('    %s=%s(\n' % (k, pk))
        for e in m[pk]:
            blueprint.write('        %s,\n' % (output_value(v[e])))
        blueprint.write('    ),\n')

def do_output_quirk_metadata(k, v):
    m = function_quirks[k]
    for pk in m.keys():
        blueprint.write('    Metadata=%s(\n' % (pk))
        blueprint.write('        %s,\n' % (output_value(v)))
        blueprint.write('    ),\n')

def do_resources_content(k, v, p=""):
    if function_quirks.has_key(k):
        x = function_quirks[k];
        if(isinstance(x, dict)):
            if(p == "Metadata"):
                do_output_quirk_metadata(k, v)
            else:
                do_output_quirk_mapping(k, v)
        elif(isinstance(x, list)):
           do_output_quirk_list(k, x[0], v)
        else:
           do_output_function(k, x, v)
    else:
        do_output_function(k, k, v)

top_level_aliases = {
    "RecordSet": "RecordSetType",
    "Policy":    "PolicyType",
}

def do_resources(d):
    """Output the template Resources"""
    blueprint.write('    def add_resources(self):\n')
    blueprint.write('        t = self.template\n')
    if PARAMETERSPRESENT == 1:
        blueprint.write('        variables = self.get_variables()\n')
    resources = d['Resources']
    for k, v in resources.items():
        object_name = objects.add(k)
        (_, tropo_object) = generate_troposphere_object(v['Type'])
        if(top_level_aliases.has_key(tropo_object)):
            tropo_object = top_level_aliases[tropo_object]
        blueprint.write('        %s = t.add_resource(%s(\n' % (
                        object_name, tropo_object))
        blueprint.write('            "%s",\n' % (k, ))
        for p in filter(lambda x: v.has_key(x), ['Metadata', 'Properties']):
            for pk, pv in v[p].items():
                if pk == "Tags":
                    blueprint.write('            Tags=Tags(\n')
                    for d in pv:
                        blueprint.write('                %s=%s,\n' % (
                            d['Key'], output_value(d['Value'])))
                    blueprint.write('            ),\n')
                elif pk == 'PortRange':
                    blueprint.write('            %s=%s(%s),\n' % (
                        pk, pk, output_dict(pv)))
                elif known_functions.has_key(pk):
                    do_resources_content(pk, pv, p)
                elif isinstance(pv, basestring):
                    blueprint.write('            %s="%s",\n' % (pk, pv))
                else:
                    blueprint.write('          %s=%s,\n' % (
                        pk, output_ref_value(pv)))
        if v.has_key("DependsOn"):
            blueprint.write('            %s=%s,\n' % (
                            "DependsOn", output_value(v['DependsOn'])))
        if v.has_key("Condition"):
            blueprint.write('            %s=%s,\n' % (
                            "Condition", output_value(v['Condition'])))
        blueprint.write('        ))\n')
        blueprint.write('\n')
        blueprint.write('\n')


def handle_no_objects(name, values):
    """Handle intrinsic functions which do not have a named resource"""
    return name + "(" + ", ".join(map(output_value, values)) + ")"

def handle_one_object(name, values):
    """Handle intrinsic functions which have a single named resource"""
    ret = name + "("
    if name == "variables":
        for i, param in enumerate(values):
            if i > 0:
                ret += ", "
            """ First parameter might be an object name or pseudo parameter """
            if i == 0:
                ret += objects.lookup(param)
            else:
                ret += output_value(param)

        return ret + ").ref"
    for i, param in enumerate(values):
        if i > 0:
            ret += ", "
        """ First parameter might be an object name or pseudo parameter """
        if i == 0:
            ret += objects.lookup(param)
        else:
            ret += output_value(param)
    return ret + ")"


function_map = {
    'Fn::Base64': ("Base64", handle_no_objects),
    'Fn::And': ("And", handle_no_objects),
    'Fn::Or': ("Or", handle_no_objects),
    'Fn::Not': ("Not", handle_no_objects),
    'Fn::If': ("If", handle_one_object),
    'Fn::Equals': ("Equals", handle_no_objects),
    'Fn::FindInMap': ("FindInMap", handle_no_objects),
    'Fn::GetAtt': ("GetAtt", handle_one_object),
    'Fn::GetAZs': ("GetAZs", handle_no_objects),
    'Fn::Join': ("Join", handle_no_objects),
    'Fn::Select': ("Select", handle_one_object),
    'Ref': ("variables", handle_one_object),
    'pseudoparameter': ("Ref", handle_one_object),
    'tropo_object': ("Ref", handle_one_object),
    'Condition': ("Condition", handle_one_object),
}

pseudoparameter_map = [
    'AWS::AccountId',
    'AWS::NotificationARNs',
    'AWS::NoValue',
    'AWS::StackId',
    'AWS::Region',
    'AWS::StackName',
]


def output_value(v):
    """Output a value which may be a string or a set of function calls."""
    if isinstance(v, basestring):
        return '"%s"' % (v.replace('\\', '\\\\').replace(
            '\n', '\\n').replace("\"", "\\\""))
    elif isinstance(v, bool):
        return '%s' % (str(v))
    elif isinstance(v, int):
        return '%d' % (v)
    elif isinstance(v, list):
        return "[" + ", ".join(map(output_value, v)) + "]"
    else:
        pass

    out = []
    """ Should only be one of these...
     checking if pseudoparameter and non CFN parameters, leaving Ref alone """
    for fk, fv in v.items():
        if fv in pseudoparameter_map:
            fk = "pseudoparameter"
            (shortname, handler) = function_map[fk]
            if not isinstance(fv, list):
                fv = [fv]
            return handler(shortname, fv)
        elif isinstance(fv, unicode) and fk == "Ref":
            if fv not in PARAMS:
                fk = "tropo_object"
                (shortname, handler) = function_map[fk]
                if not isinstance(fv, list):
                    fv = [fv]
                return handler(shortname, fv)
            elif fk in function_map:
                (shortname, handler) = function_map[fk]
                if not isinstance(fv, list):
                    fv = [fv]
                return handler(shortname, fv)
            else:
                out.append( '"' + fk + '": ' + output_value(fv))
        else:
            out.append( '"' + fk + '": ' + output_value(fv))

    return "{ " + ", ".join(out) + " }"

def output_ref_value(v):
    """Output a value which may be a string or a set of function calls."""
    if type(v) == dict:
        for key, value in v.items():
            if key == "Ref":
                if value not in PARAMS:
                    return "Ref(" + value + ")"
                else:
                    return "variables[\'" + value + "\'].ref"
            else:
                return output_value(v)

    else:
        return output_value(v)

def do_outputs(d):
    """Output the template Outputs"""
    global OUTPUTSPRESENT
    OUTPUTSPRESENT = 1
    blueprint.write('    def add_outputs(self):\n')
    blueprint.write('        t = self.template\n')
    outputs = d['Outputs']
    for k, v in outputs.items():
        blueprint.write('        %s = t.add_output(Output(\n' % (k,))
        blueprint.write('            "%s",\n' % (k, ))
        for pk, pv in v.items():
            if isinstance(pv, basestring):
                blueprint.write('            %s="%s",\n' % (pk, pv))
            else:
                blueprint.write('          %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('            ))\n')
        blueprint.write('\n')
        blueprint.write('\n')


def do_trailer(d):
    """Output a trailer section for the new Python script."""
    blueprint.write('    """ Below function is what is called by the '
                    'stacker build action """\n')
    blueprint.write('    def create_template(self):\n')
    if CONDITIONSPRESENT == 1:
        blueprint.write('        self.add_conditions()\n')
    if AWSTEMPLATEFORMATVERSIONPRESENT == 1:
        blueprint.write('        self.add_cfn_version()\n')
    if DESCRIPTIONPRESENT == 1:
        blueprint.write('        self.add_cfn_description()\n')
    if MAPPINGSPRESENT == 1:
        blueprint.write('    """ Note: Stacker supports mappings in it\'s')
        blueprint.write(' yaml config\n    It\'s a good idea to move these')
        blueprint.write(' there. """\n')
        blueprint.write('        self.add_mappings()\n')
    blueprint.write('        self.add_resources()\n')
    if OUTPUTSPRESENT == 1:
        blueprint.write('        self.add_outputs()\n')



if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("template", help="json template to convert")
    parser.add_argument("blueprint", help="blueprint .py file to create. Used "
                        "for file name and class name in the blueprint")
    args = parser.parse_args()

    d = json.load(open(args.template))

    blueprint = open(args.blueprint, 'w+')

    do_header(d)
    do_classdefinition(d)
    sections = [
        'Parameters',
        'Conditions',
        'AWSTemplateFormatVersion',
        'Description',
        'Mappings',
        'Resources',
        'Outputs',
    ]

    for s in sections:
        if s in d.keys():
            globals()["do_" + s.lower()](d)

    do_trailer(d)
