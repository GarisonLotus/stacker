#!/usr/bin/env python
"""
This cfn2blueprint script originally sourced, but heavily modified from cfn2py
in the troposphere repo from commit 933e6565b2a8330dd8100470002c7f3b520bf0d5.

This script will attempt to convert your existing CFN JSON template to
a stacker blueprint. It converts the JSON exactly as written and is intended
to give you a starting point allowing you to use stacker with existing stacks.
The idea is that you would have a resulting blueprint that matches your
existing stack exactly when you execute a stacker build against the stack
with the new blueprint. This script is not perfect and you will most likely
have to still modify your blueprint to get it to work. This does not generate
a stacker config, only the blueprint itself. See the Known issues
section below.

Usage example: cfn2blueprint ./sturdycore.json ./sturdycore.py

The result will be a python template named "sturdycore.py" with a class
named "sturdycore"

Known issues:
    1) troposphere objects are created in the exact order they are
in the JSON. Because of this, Ref statements referencing Python Objects might
be placed in the blueprint before assignment. The fix is to move the object
being referenced so it gets assigned before the reference itself.
    2) IAM Roles can get generated incorrectly. If you find your IAM role
not being generated correctly, we recommend importing the awacs module, and use
awacs to generate objects instead. Visit https://github.com/cloudtools/awacs
for more information on that.



Templates might not get generated perfectly. When you are ready to try against
running stacks, we heavily recommend running stacker build with interactive
mode on the first time to find problems in your blueprint. Even then, you will
most likely need to make changes to your blueprint before it will work.


"""
import argparse
import json


class object_registry(object):
    """Keep track of objects being created as Parameters or Resources
    in order to map back to due to use in intrinsic functions like
    Ref() and GetAtt().
    """
    global CONDITIONSPRESENT
    CONDITIONSPRESENT = 0
    global AWSTEMPLATEFORMATVERSIONPRESENT
    AWSTEMPLATEFORMATVERSIONPRESENT = 0
    global DESCRIPTIONPRESENT
    DESCRIPTIONPRESENT = 0
    global MAPPINGSPRESENT
    MAPPINGSPRESENT = 0
    global OUTPUTSPRESENT
    OUTPUTSPRESENT = 0
    global PARAMETERSPRESENT
    PARAMETERSPRESENT = 0
    global PARAMS
    PARAMS = []
    """ this above PARAMS global list is used later to determine if a Ref is a
     Ref to a CFN paramter or if it's a Ref to another Python object """

    def __init__(self):
        self.objects = {}

    def add(self, o):
        new_name = o.replace('-', '_')
        self.objects[o] = new_name
        return new_name

    def lookup(self, o):
        if o in self.objects:
            return self.objects[o]
        else:
            return output_value(o)

objects = object_registry()

object_functions = {
    "Table":        [ "ProvisionedThroughput", "PrimaryKey", "Element" ],
    "LoadBalancer": [ "HealthCheck", "ConnectionDrainingPolicy", "AccessLoggingPolicy" ],
    "Queue":        [ "RedrivePolicy" ],
    "Bucket":       [ "WebsiteConfiguration" ],
    "User":         [ "LoginProfile" ],
    "Topic":        [ "Subscription" ],
    "Instance":     [ "NetworkInterfaceProperty", "PrivateIpAddressSpecification" ],
    "RecordSet":    [ "RecordSetType" ],
    "Policy":       [ "PolicyType" ],
}

def additional_imports(o):
    if object_functions.has_key(o):
        return ", ".join([o] + object_functions[o])
    else:
        return o

""" generating the blueprint header """
def do_header(d):
    """Output a stock header for the new Python script and also try to
    figure out the Resource imports needed by the template.
    """
    blueprint.write('from troposphere import (\n')
    blueprint.write('    Base64, Select, FindInMap, GetAtt, GetAZs, Join,\n')
    blueprint.write('    Output, If, And, Not, Or, Equals, Condition\n)\n')
    blueprint.write('from troposphere import Parameter, Ref, Tags, Template\n')
    blueprint.write('from troposphere.cloudformation import Init\n')
    blueprint.write('from troposphere.cloudfront import (\n')
    blueprint.write('    Distribution, DistributionConfig, Origin,\n')
    blueprint.write('    DefaultCacheBehavior\n)\n')
    blueprint.write('from troposphere.ec2 import PortRange\n')
    blueprint.write('from stacker.blueprints.variables.types import (\n')
    blueprint.write('    CFNString, CFNNumber, CFNNumberList,\n')
    blueprint.write('    CFNCommaDelimitedList, EC2AvailabilityZoneName,\n')
    blueprint.write('    EC2ImageId, EC2ImageId, EC2InstanceId,\n')
    blueprint.write('    EC2KeyPairKeyName, EC2SecurityGroupGroupName,\n')
    blueprint.write('    EC2SecurityGroupId, EC2SubnetId, EC2VolumeId,\n')
    blueprint.write('    EC2VPCId, Route53HostedZoneId,\n')
    blueprint.write('    EC2AvailabilityZoneNameList, EC2ImageIdList,\n')
    blueprint.write('    EC2InstanceIdList, EC2SecurityGroupGroupNameList,\n')
    blueprint.write('    EC2SecurityGroupIdList, EC2SubnetIdList,\n')
    blueprint.write('    EC2VolumeIdList, EC2VPCIdList,\n')
    blueprint.write('    Route53HostedZoneIdList,\n')
    blueprint.write(')\n')

    """ Loop over the resources to find imports """
    if 'Resources' in d:
        seen = []
        resources = d['Resources']
        for k, v in resources.items():
            (mod, tropo_object) = generate_troposphere_object(v['Type'])
            if tropo_object not in seen:
                seen.append(tropo_object)
                blueprint.write('from troposphere.%s import %s\n' % (
                                mod, additional_imports(tropo_object)))
    blueprint.write('from stacker.blueprints.base import Blueprint\n')
    blueprint.write('\n')

def do_classdefinition(d):
    """Output the Class"""
    CLASSNAME = args.blueprint.replace(".py", "")
    CLASSNAME = CLASSNAME.replace(".", "")
    CLASSNAME = CLASSNAME.replace("/", "")
    CLASSNAME = CLASSNAME.replace("-", "")
    blueprint.write('class %s(Blueprint):\n' % (CLASSNAME))
    blueprint.write('    """\n    cfn2blueprint generated blueprint converted '
                    'from cloudformation into a stacker blueprint\n\n    The '
                    'Class name would be called in your class path in the '
                    'stacker config. In the class itself are\n    functions '
                    'that are added when dectected in your source CFN '
                    'template.\n\n\n    Each function is called by the '
                    'create_template function at the bottem of this ')
    blueprint.write('blueprint\n\n\n\n    We recomend running stacker diff ')
    blueprint.write('or build with interactive mode on the first time to \n ')
    blueprint.write('   ensure the blueprint was corectly generated.    """\n')
    blueprint.write('\n')

def do_awstemplateformatversion(d):
    """Output the template version"""
    global AWSTEMPLATEFORMATVERSIONPRESENT
    AWSTEMPLATEFORMATVERSIONPRESENT = 1
    blueprint.write('    def add_cfn_version(self):\n')
    blueprint.write('        template = self.template\n')
    blueprint.write('        template.add_version("%s")\n' % (
        d['AWSTemplateFormatVersion'], ))
    blueprint.write('\n')


def do_description(d):
    """Output the template Description"""
    global DESCRIPTIONPRESENT
    DESCRIPTIONPRESENT = 1
    blueprint.write('    def add_cfn_description(self):\n')
    blueprint.write('        template = self.template\n')
    blueprint.write('        template.add_description(\n            "'
                    '%s"\n        )\n' % (d['Description'], ))
    blueprint.write('\n')


def do_parameters(d):

    params_to_varibles = {
        "String": "CFNString",
        "Number": "CFNNumber",
        "List<Number>": "CFNNumberList",
        "CommaDelimitedList": "CFNCommaDelimitedList",
        "AWS::EC2::AvailabilityZone::Name": "EC2AvailabilityZoneName",
        "AWS::EC2::Image::Id": "EC2ImageId",
        "AWS::EC2::Instance::Id": "EC2InstanceId",
        "AWS::EC2::KeyPair::KeyName": "EC2KeyPairKeyName",
        "AWS::EC2::SecurityGroup::GroupName": "EC2SecurityGroupGroupName",
        "AWS::EC2::SecurityGroup::Id": "EC2SecurityGroupId",
        "AWS::EC2::Subnet::Id": "EC2SubnetId",
        "AWS::EC2::Volume::Id": "EC2VolumeId",
        "AWS::EC2::VPC::Id": "EC2VPCId",
        "AWS::Route53::HostedZone::Id": "Route53HostedZoneId",
        "List<AWS::EC2::AvailabilityZone::Name>":
            "EC2AvailabilityZoneNameList",
        "List<AWS::EC2::Image::Id>": "EC2ImageIdList",
        "List<AWS::EC2::Instance::Id>": "EC2InstanceIdList",
        "List<AWS::EC2::SecurityGroup::GroupName>":
            "EC2SecurityGroupGroupNameList",
        "List<AWS::EC2::SecurityGroup::Id>": "EC2SecurityGroupIdList",
        "List<AWS::EC2::Subnet::Id>": "EC2SubnetIdList",
        "List<AWS::EC2::Volume::Id>": "EC2VolumeIdList",
        "List<AWS::EC2::VPC::Id>": "EC2VPCIdList",
        "List<AWS::Route53::HostedZone::Id>": "Route53HostedZoneIdList",
    }

    """Output the template Parameters as stacker Varibles"""
    global PARAMETERSPRESENT
    PARAMETERSPRESENT = 1
    params = d['Parameters']
    blueprint.write('    VARIABLES = {\n')
    for k, v in params.items():
        global PARAMS
        PARAMS.append(k)
        blueprint.write('        \"%s\": {\n' % (k,))
        for vk, vv in v.items():
            if type(vv) is not list:
                if params_to_varibles.has_key(vv):
                    m = params_to_varibles[vv]
                    blueprint.write('            \"type\": %s,\n' % (m))
            if vk == "Default":
                blueprint.write('            \"default\": \"%s\",\n' % (vv))
            if vk == "NoEcho":
                blueprint.write('            \"no_echo\": \"%s\",\n' % (vv))
            if vk == "Description":
                blueprint.write('            \"description\": \"%s\",\n' % (
                            vv))
            if vk == "AllowedValues":
                allowed = []
                for allowedvalue in vv:
                    allowed.append(str(allowedvalue))
                blueprint.write('            \"allowed_values\": %s,\n' % (
                    allowed))
            if vk == "AllowedPattern":
                blueprint.write('            \"allowed_pattern\": \"%s\",\n' %
                                (vv))
            if vk == "MaxLength":
                blueprint.write('            \"max_length\": \"%s\",\n' % (vv))
            if vk == "MinLength":
                blueprint.write('            \"min_length\": \"%s\",\n' % (vv))
            if vk == "MaxValue":
                blueprint.write('            \"max_value\": \"%s\",\n' % (vv))
            if vk == "MinValue":
                blueprint.write('            \"min_value\": \"%s\",\n' % (vv))
            if vk == "ConstraintDescription":
                blueprint.write('            \"constraint_description\":')
                blueprint.write(' \"%s\",\n' % (vv))
            else:
                pass
        blueprint.write('        },\n')
    blueprint.write('    }\n')
    blueprint.write('\n\n')


def do_conditions(d):
    """Output the template Conditions"""
    global CONDITIONSPRESENT
    CONDITIONSPRESENT = 1
    blueprint.write('    def add_conditions(self):\n')
    blueprint.write('        template = self.template\n')
    blueprint.write('        variables = self.get_variables()\n')
    conditions = d['Conditions']
    for k, v in conditions.items():
        blueprint.write('        template.add_condition("%s",\n' % (k,))
        blueprint.write('            %s\n' % output_value(v))
        blueprint.write('        )\n')
        blueprint.write('\n')

def do_mappings(d):
    """Output the template Mappings"""
    global MAPPINGSPRESENT
    MAPPINGSPRESENT = 1
    blueprint.write('    """ Note: Stacker has support for mappings in the')
    blueprint.write(' yaml config\n    It\'s a good idea to move these')
    blueprint.write(' there. """\n')
    blueprint.write('    def add_mappings(self):\n')
    blueprint.write('        template = self.template\n')
    blueprint.write('        variables = self.get_variables()\n')
    mappings = d['Mappings']
    for k, v in mappings.items():
        blueprint.write('        template.add_mapping("%s", {\n' % (k,))
        for vk, vv in v.items():
            for vvk, vvv in vv.items():
                blueprint.write('            "%s": {"%s": "%s"},\n' % (
                        vk, vvk, vvv))
        blueprint.write('        })\n')
        blueprint.write('        \n')

def map_module(mod):
    """Map module names as needed"""
    if mod == "lambda":
        return "awslambda"
    return mod


def generate_troposphere_object(typename):
    """Try to determine the troposphere object to create from the Type
    specification from the Resource being converted.
    """
    t = typename.split(':')
    if len(t) == 5:
        return (map_module(t[2].lower()), t[4])
    else:
        return ('', typename)


def output_dict(d):
    out = []
    for k,v in d.items():
        out.append("%s=%s" % (k.replace('\\', '\\\\'), output_value(v)))
    return ", ".join(out)

known_functions = {
    "DistributionConfig":       1,
    "DefaultCacheBehavior":     1,
    "ProvisionedThroughput":    1,
    "NetworkInterfaces":        1,
    "WebsiteConfiguration":     1,
    "RedrivePolicy":            1,
    "Subscription":             1,
    "KeySchema":                1,
    "HashKeyElement":           1,
    "HealthCheck":              1,
    "LoginProfile":             1,
    "ConnectionDrainingPolicy": 1,
    "AccessLoggingPolicy":      1,
    "AWS::CloudFormation::Init":1,
    "PrivateIpAddresses"       :1,
    "ContainerDefinitions"     :1,
}

function_quirks = {
    "KeySchema":          "PrimaryKey",
    "HashKeyElement":     { "Element": ["AttributeName", "AttributeType"] },
    "NetworkInterfaces":  [ "NetworkInterfaceProperty" ],
    "Subscription":       [ "Subscription" ],
    "LoginProfile":       { "LoginProfile": ["Password"] },
    "AWS::CloudFormation::Init": {"Init": []},
    "PrivateIpAddresses": ["PrivateIpAddressSpecification"],
    "ContainerDefinitions": ["ContainerDefinition"],
}

def do_output_function(k, f, v):
    blueprint.write('    %s=%s(\n' % (k, f))
    for pk, pv in v.items():
        if known_functions.has_key(pk):
            do_resources_content(pk, pv, "")
        else:
            blueprint.write('        %s=%s,\n' % (pk, output_value(pv)))
    blueprint.write('    ),\n')

def do_output_quirk_list(k, f, v):
    blueprint.write('    %s=[\n' % (k))
    for e in v:
        blueprint.write('    %s(\n' % (f))
        for pk, pv in e.items():
            if known_functions.has_key(pk):
                do_resources_content(pk, pv)
            else:
                blueprint.write('        %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('    ),\n')
    blueprint.write('    ],\n')

def do_output_quirk_mapping(k, v):
    m = function_quirks[k]
    for pk in m.keys():
        blueprint.write('    %s=%s(\n' % (k, pk))
        for e in m[pk]:
            blueprint.write('        %s,\n' % (output_value(v[e])))
        blueprint.write('    ),\n')

def do_output_quirk_metadata(k, v):
    m = function_quirks[k]
    for pk in m.keys():
        blueprint.write('    Metadata=%s(\n' % (pk))
        blueprint.write('        %s,\n' % (output_value(v)))
        blueprint.write('    ),\n')

def do_resources_content(k, v, p=""):
    if function_quirks.has_key(k):
        x = function_quirks[k];
        if(isinstance(x, dict)):
            if(p == "Metadata"):
                do_output_quirk_metadata(k, v)
            else:
                do_output_quirk_mapping(k, v)
        elif(isinstance(x, list)):
           do_output_quirk_list(k, x[0], v)
        else:
           do_output_function(k, x, v)
    else:
        do_output_function(k, k, v)

top_level_aliases = {
    "RecordSet": "RecordSetType",
    "Policy":    "PolicyType",
}

def do_resources(d):
    """Output the template Resources"""
    blueprint.write('    def add_resources(self):\n')
    blueprint.write('        template = self.template\n')
    blueprint.write('        variables = self.get_variables()\n')
    resources = d['Resources']
    for k, v in resources.items():
        object_name = objects.add(k)
        (_, tropo_object) = generate_troposphere_object(v['Type'])
        if(top_level_aliases.has_key(tropo_object)):
            tropo_object = top_level_aliases[tropo_object]
        blueprint.write('        %s = template.add_resource(%s(\n' % (
                        object_name, tropo_object))
        blueprint.write('            "%s",\n' % (k, ))
        for p in filter(lambda x: v.has_key(x), ['Metadata', 'Properties']):
            for pk, pv in v[p].items():
                if pk == "Tags":
                    blueprint.write('            Tags=Tags(\n')
                    for d in pv:
                        blueprint.write('                  %s=%s,\n' % (
                            d['Key'], output_value(d['Value'])))
                    blueprint.write('            ),\n')
                elif pk == 'PortRange':
                    blueprint.write('              %s=%s(%s),\n' % (
                        pk, pk, output_dict(pv)))
                elif known_functions.has_key(pk):
                    do_resources_content(pk, pv, p)
                elif isinstance(pv, basestring):
                    blueprint.write('            %s="%s",\n' % (pk, pv))
                else:
                    blueprint.write('            %s=%s,\n' % (
                        pk, output_ref_value(pv)))
        if v.has_key("DependsOn"):
            blueprint.write('            %s=%s,\n' % (
                            "DependsOn", output_value(v['DependsOn'])))
        if v.has_key("Condition"):
            blueprint.write('            %s=%s,\n' % (
                            "Condition", output_value(v['Condition'])))
        blueprint.write('        ))\n')
        blueprint.write('\n')


def handle_no_objects(name, values):
    """Handle intrinsic functions which do not have a named resource"""
    return name + "(" + ", ".join(map(output_value, values)) + ")"

def handle_one_object(name, values):
    """Handle intrinsic functions which have a single named resource"""
    ret = name + "("
    if name == "variables":
        ret = name + "["
        for i, param in enumerate(values):
            if i > 0:
                ret += ", "
            """ First parameter might be an object name or pseudo parameter """
            if i == 0:
                ret += objects.lookup(param)
            else:
                ret += output_value(param)

        return ret + "].ref"
    for i, param in enumerate(values):
        if i > 0:
            ret += ", "
        """ First parameter might be an object name or pseudo parameter """
        if i == 0:
            ret += objects.lookup(param)
        else:
            ret += output_value(param)
    return ret + ")"


function_map = {
    'Fn::Base64': ("Base64", handle_no_objects),
    'Fn::And': ("And", handle_no_objects),
    'Fn::Or': ("Or", handle_no_objects),
    'Fn::Not': ("Not", handle_no_objects),
    'Fn::If': ("If", handle_one_object),
    'Fn::Equals': ("Equals", handle_no_objects),
    'Fn::FindInMap': ("FindInMap", handle_no_objects),
    'Fn::GetAtt': ("GetAtt", handle_one_object),
    'Fn::GetAZs': ("GetAZs", handle_no_objects),
    'Fn::Join': ("Join", handle_no_objects),
    'Fn::Select': ("Select", handle_one_object),
    'Ref': ("variables", handle_one_object),
    'pseudoparameter': ("Ref", handle_one_object),
    'tropo_object': ("Ref", handle_one_object),
    'Condition': ("Condition", handle_one_object),
}

pseudoparameter_map = [
    'AWS::AccountId',
    'AWS::NotificationARNs',
    'AWS::NoValue',
    'AWS::StackId',
    'AWS::Region',
    'AWS::StackName',
]


def output_value(v):
    """Output a value which may be a string or a set of function calls."""
    if isinstance(v, basestring):
        return '"%s"' % (v.replace('\\', '\\\\').replace(
            '\n', '\\n').replace("\"", "\\\""))
    elif isinstance(v, bool):
        return '%s' % (str(v))
    elif isinstance(v, int):
        return '%d' % (v)
    elif isinstance(v, list):
        return "[" + ", ".join(map(output_value, v)) + "]"
    else:
        pass

    out = []
    """ Should only be one of these...
     checking if pseudoparameter and non CFN parameters, leaving Ref alone """
    for fk, fv in v.items():
        if fv in pseudoparameter_map:
            fk = "pseudoparameter"
            (shortname, handler) = function_map[fk]
            if not isinstance(fv, list):
                fv = [fv]
            return handler(shortname, fv)
        elif isinstance(fv, unicode) and fk == "Ref":
            if fv not in PARAMS:
                fk = "tropo_object"
                (shortname, handler) = function_map[fk]
                if not isinstance(fv, list):
                    fv = [fv]
                return handler(shortname, fv)
            elif fk in function_map:
                (shortname, handler) = function_map[fk]
                if not isinstance(fv, list):
                    fv = [fv]
                return handler(shortname, fv)
            else:
                out.append( '"' + fk + '": ' + output_value(fv))
        elif fk in function_map:
            (shortname, handler) = function_map[fk]
            if not isinstance(fv, list):
                fv = [fv]
            return handler(shortname, fv)
        else:
            out.append( '"' + fk + '": ' + output_value(fv))

    return "{ " + ", ".join(out) + " }"

def output_ref_value(v):
    """Output a value which may be a string or a set of function calls."""
    if type(v) == dict:
        for key, value in v.items():
            if key == "Ref":
                if value not in PARAMS:
                    return "Ref(" + value + ")"
                else:
                    return "variables[\'" + value + "\'].ref"
            else:
                return output_value(v)

    else:
        return output_value(v)


def do_outputs(d):
    """Output the template Outputs"""
    outputs = d['Outputs']
    for k, v in outputs.items():
        blueprint.write('        template.add_output(Output(\n')
        blueprint.write('            "%s",\n' % (k, ))
        for pk, pv in v.items():
            if isinstance(pv, basestring):
                blueprint.write('            %s="%s",\n' % (pk, pv))
            else:
                blueprint.write('            %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('            ))\n')
        blueprint.write('\n')


def do_trailer(d):
    """Output a trailer section for the new Python script."""
    blueprint.write('    """ Below function is what is called by the '
                    'stacker build action """\n')
    blueprint.write('    def create_template(self):\n')
    if CONDITIONSPRESENT == 1:
        blueprint.write('        self.add_conditions()\n')
    if AWSTEMPLATEFORMATVERSIONPRESENT == 1:
        blueprint.write('        self.add_cfn_version()\n')
    if DESCRIPTIONPRESENT == 1:
        blueprint.write('        self.add_cfn_description()\n')
    if MAPPINGSPRESENT == 1:
        blueprint.write('        self.add_mappings()\n')
    blueprint.write('        self.add_resources()\n')


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("template", help="json template to convert")
    parser.add_argument("blueprint", help="blueprint .py file to create. Used "
                        "for file name and class name in the blueprint")
    args = parser.parse_args()

    d = json.load(open(args.template))

    blueprint = open(args.blueprint, 'w+')

    do_header(d)
    do_classdefinition(d)
    sections = [
        'Parameters',
        'Conditions',
        'AWSTemplateFormatVersion',
        'Description',
        'Mappings',
        'Resources',
        'Outputs',
    ]

    for s in sections:
        if s in d.keys():
            globals()["do_" + s.lower()](d)

    do_trailer(d)
