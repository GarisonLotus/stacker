#!/usr/bin/env python


import argparse
import json
import pprint


class object_registry(object):
    """Keep track of objects being created as Parameters or Resources
    in order to map back to due to use in intrinsic functions like
    Ref() and GetAtt().
    """
    global CONDITIONSPRESENT
    CONDITIONSPRESENT = 0
    global AWSTEMPLATEFORMATVERSIONPRESENT
    AWSTEMPLATEFORMATVERSIONPRESENT = 0
    global DESCRIPTIONPRESENT
    DESCRIPTIONPRESENT = 0
    global MAPPINGSPRESENT
    MAPPINGSPRESENT = 0
    global OUTPUTSPRESENT
    OUTPUTSPRESENT = 0
    global PARAMETERSPRESENT
    PARAMETERSPRESENT = 0

    def __init__(self):
        self.objects = {}

    def add(self, o):
        new_name = o.replace('-', '_')
        self.objects[o] = new_name
        return new_name

    def lookup(self, o):
        if o in self.objects:
            return self.objects[o]
        else:
            return output_value(o)

objects = object_registry()

object_functions = {
    "Table":        [ "ProvisionedThroughput", "PrimaryKey", "Element" ],
    "LoadBalancer": [ "HealthCheck", "ConnectionDrainingPolicy", "AccessLoggingPolicy" ],
    "Queue":        [ "RedrivePolicy" ],
    "Bucket":       [ "WebsiteConfiguration" ],
    "User":         [ "LoginProfile" ],
    "Topic":        [ "Subscription" ],
    "Instance":     [ "NetworkInterfaceProperty", "PrivateIpAddressSpecification" ],
    "RecordSet":    [ "RecordSetType" ],
    "Policy":       [ "PolicyType" ],
}

def additional_imports(o):
    if object_functions.has_key(o):
        return ", ".join([o] + object_functions[o])
    else:
        return o

def do_header(d):
    """Output a stock header for the new Python script and also try to
    figure out the Resource imports needed by the template.
    """
    blueprint.write('from troposphere import Base64, Select, FindInMap, GetAtt, GetAZs, Join, Output, If, And, Not, Or, Equals, Condition\n')
    blueprint.write('from troposphere import Parameter, Ref, Tags, Template\n')
    blueprint.write('from troposphere.cloudformation import Init\n')
    blueprint.write('from troposphere.cloudfront import Distribution, DistributionConfig\n')
    blueprint.write('from troposphere.cloudfront import Origin, DefaultCacheBehavior\n')
    blueprint.write('from troposphere.ec2 import PortRange\n')
    blueprint.write('from stacker.blueprints.variables.types import (\n')
    blueprint.write('    CFNString, CFNNumber, CFNNumberList,\n')
    blueprint.write('    CFNCommaDelimitedList, EC2AvailabilityZoneName,\n')
    blueprint.write('    EC2ImageId, EC2ImageId, EC2InstanceId,\n')
    blueprint.write('    EC2KeyPairKeyName, EC2SecurityGroupGroupName,\n')
    blueprint.write('    EC2SecurityGroupId, EC2SubnetId, EC2VolumeId,\n')
    blueprint.write('    EC2VPCId, Route53HostedZoneId,\n')
    blueprint.write('    EC2AvailabilityZoneNameList, EC2ImageIdList,\n')
    blueprint.write('    EC2InstanceIdList, EC2SecurityGroupGroupNameList,\n')
    blueprint.write('    EC2SecurityGroupIdList, EC2SubnetIdList,\n')
    blueprint.write('    EC2VolumeIdList, EC2VPCIdList,\n')
    blueprint.write('    Route53HostedZoneIdList,\n')
    blueprint.write(')\n')


    # Loop over the resources to find imports
    if 'Resources' in d:
        seen = []
        resources = d['Resources']
        for k, v in resources.items():
            (mod, tropo_object) = generate_troposphere_object(v['Type'])
            if tropo_object not in seen:
                seen.append(tropo_object)
                blueprint.write('from troposphere.%s import %s \n' % (
                                mod, additional_imports(tropo_object)))
    blueprint.write('\n')
    blueprint.write('\n')

def do_classdefinition(d):
    """Output the Class"""
    CLASSNAME = args.blueprint.replace(".py", "")
    CLASSNAME = CLASSNAME.replace(".", "")
    CLASSNAME = CLASSNAME.replace("/", "")
    blueprint.write('class %s(Blueprint):\n' % (CLASSNAME))
    blueprint.write('    """ cfn2blueprint generated blueprint converted from '
                    'cloudformation  into a stacker blueprint\n\n    The Class'
                    ' name would be called in your class path in the stacker '
                    'config. In the class are\n    seperate functions that are'
                    ' added when dectected in your source CFN template."""\n'
                    '\n\n    Each function is called by the create_template '
                    'function at the bottem of this blueprint')
    blueprint.write('\n')
    blueprint.write('\n')

def do_awstemplateformatversion(d):
    """Output the template version"""
    global AWSTEMPLATEFORMATVERSIONPRESENT
    AWSTEMPLATEFORMATVERSIONPRESENT = 1
    blueprint.write('    def add_cfn_version(self):\n')
    blueprint.write('        t = self.template\n')
    blueprint.write('        t.add_version("%s")\n' % (
        d['AWSTemplateFormatVersion'], ))
    blueprint.write('\n')
    blueprint.write('\n')


def do_description(d):
    """Output the template Description"""
    global DESCRIPTIONPRESENT
    DESCRIPTIONPRESENT = 1
    blueprint.write('    def add_cfn_description(self):\n')
    blueprint.write('        t = self.template\n')
    blueprint.write('        t.add_description(\n            "'
                    '%s"\n        )\n' % (d['Description'], ))
    blueprint.write('\n')
    blueprint.write('\n')


def do_parameters(d):
    """Output the template Parameters"""
    global PARAMETERSPRESENT
    PARAMETERSPRESENT = 1
    params = d['Parameters']
    for k, v in params.items():
        object_name = objects.add(k)
        blueprint.write('%s = t.add_parameter(Parameter(\n' % (object_name,))
        blueprint.write('    "%s",\n' % (k, ))
        for pk, pv in v.items():
            blueprint.write('    %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('))\n')
        blueprint.write('\n')


def do_conditions(d):
    """Output the template Conditions"""
    global CONDITIONSPRESENT
    CONDITIONSPRESENT = 1
    blueprint.write('    def add_conditions(self):\n')
    blueprint.write('        t = self.template\n')
    conditions = d['Conditions']
    for k, v in conditions.items():
        blueprint.write('        t.add_condition("%s",\n' % (k,))
        blueprint.write('    %s\n' % output_value(v))
        blueprint.write('        )\n')
        blueprint.write('\n')

def do_mappings(d):
    """Output the template Mappings"""
    global MAPPINGSPRESENT
    MAPPINGSPRESENT = 1
    blueprint.write('    def add_mappings(self):\n')
    blueprint.write('        t = self.template\n')
    mappings = d['Mappings']
    for k, v in mappings.items():
        blueprint.write('        t.add_mapping("%s",\n' % (k,))
        pprint.pprint(v)
        blueprint.write('        )\n')
        blueprint.write('        \n')


def map_module(mod):
    """Map module names as needed"""
    if mod == "lambda":
        return "awslambda"
    return mod


def generate_troposphere_object(typename):
    """Try to determine the troposphere object to create from the Type
    specification from the Resource being converted.
    """
    t = typename.split(':')
    if len(t) == 5:
        return (map_module(t[2].lower()), t[4])
    else:
        return ('', typename)


def output_dict(d):
    out = []
    for k,v in d.items():
        out.append("%s=%s" % (k.replace('\\', '\\\\'), output_value(v)))
    return ", ".join(out)

known_functions = {
    "DistributionConfig":       1,
    "DefaultCacheBehavior":     1,
    "ProvisionedThroughput":    1,
    "NetworkInterfaces":        1,
    "WebsiteConfiguration":     1,
    "RedrivePolicy":            1,
    "Subscription":             1,
    "KeySchema":                1,
    "HashKeyElement":           1,
    "HealthCheck":              1,
    "LoginProfile":             1,
    "ConnectionDrainingPolicy": 1,
    "AccessLoggingPolicy":      1,
    "AWS::CloudFormation::Init":1,
    "PrivateIpAddresses"       :1,
    "ContainerDefinitions"     :1,
}

function_quirks = {
    "KeySchema":          "PrimaryKey",
    "HashKeyElement":     { "Element": ["AttributeName", "AttributeType"] },
    "NetworkInterfaces":  [ "NetworkInterfaceProperty" ],
    "Subscription":       [ "Subscription" ],
    "LoginProfile":       { "LoginProfile": ["Password"] },
    "AWS::CloudFormation::Init": {"Init": []},
    "PrivateIpAddresses" : ["PrivateIpAddressSpecification"],
    "ContainerDefinitions": ["ContainerDefinition"],
}

def do_output_function(k, f, v):
    blueprint.write('    %s=%s(\n' % (k, f))
    for pk, pv in v.items():
        if known_functions.has_key(pk):
            do_resources_content(pk, pv, "")
        else:
            blueprint.write('        %s=%s,\n' % (pk, output_value(pv)))
    blueprint.write('    ),\n')

def do_output_quirk_list(k, f, v):
    blueprint.write('    %s=[\n' % (k))
    for e in v:
        blueprint.write('    %s(\n' % (f))
        for pk, pv in e.items():
            if known_functions.has_key(pk):
                do_resources_content(pk, pv)
            else:
                blueprint.write('        %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('    ),\n')
    blueprint.write('    ],\n')

def do_output_quirk_mapping(k, v):
    m = function_quirks[k]
    for pk in m.keys():
        blueprint.write('    %s=%s(\n' % (k, pk))
        for e in m[pk]:
            blueprint.write('        %s,\n' % (output_value(v[e])))
        blueprint.write('    ),\n')

def do_output_quirk_metadata(k, v):
    m = function_quirks[k]
    for pk in m.keys():
        blueprint.write('    Metadata=%s(\n' % (pk))
        blueprint.write('        %s,\n' % (output_value(v)))
        blueprint.write('    ),\n')

def do_resources_content(k, v, p=""):
    if function_quirks.has_key(k):
        x = function_quirks[k];
        if(isinstance(x, dict)):
            if(p == "Metadata"):
                do_output_quirk_metadata(k, v)
            else:
                do_output_quirk_mapping(k, v)
        elif(isinstance(x, list)):
           do_output_quirk_list(k, x[0], v)
        else:
           do_output_function(k, x, v)
    else:
        do_output_function(k, k, v)

top_level_aliases = {
    "RecordSet": "RecordSetType",
    "Policy":    "PolicyType",
}

def do_resources(d):
    """Output the template Resources"""
    blueprint.write('    def add_resources(self):\n')
    blueprint.write('        t = self.template\n')
    if PARAMETERSPRESENT == 1:
        blueprint.write('        variables = self.get_variables()\n')
    resources = d['Resources']
    for k, v in resources.items():
        object_name = objects.add(k)
        (_, tropo_object) = generate_troposphere_object(v['Type'])
        if(top_level_aliases.has_key(tropo_object)):
            tropo_object = top_level_aliases[tropo_object]
        blueprint.write('        %s = t.add_resource(%s(\n' % (
                        object_name, tropo_object))
        blueprint.write('            "%s",\n' % (k, ))
        for p in filter(lambda x: v.has_key(x), ['Metadata', 'Properties']):
            for pk, pv in v[p].items():
                if pk == "Tags":
                    blueprint.write('            Tags=Tags(\n')
                    for d in pv:
                        blueprint.write('                %s=%s,\n' % (
                            d['Key'], output_value(d['Value'])))
                    blueprint.write('            ),\n')
                elif pk == 'PortRange':
                    blueprint.write('            %s=%s(%s),\n' % (
                        pk, pk, output_dict(pv)))
                elif known_functions.has_key(pk):
                    do_resources_content(pk, pv, p)
                # Below is processing of strings
                elif isinstance(pv, basestring):
                    blueprint.write('            %s="%s",\n' % (pk, pv))
                # Below is processing of refs
                else:
                    blueprint.write('          %s=%s,\n' % (
                        pk, output_ref_value(pv)))
        if v.has_key("DependsOn"):
            blueprint.write('            %s=%s,\n' % (
                            "DependsOn", output_value(v['DependsOn'])))
        if v.has_key("Condition"):
            blueprint.write('            %s=%s,\n' % (
                            "Condition", output_value(v['Condition'])))
        blueprint.write('        ))\n')
        blueprint.write('\n')
        blueprint.write('\n')


def handle_no_objects(name, values):
    """Handle intrinsic functions which do not have a named resource"""
    return name + "(" + ", ".join(map(output_value, values)) + ")"

def handle_one_object(name, values):
    """Handle intrinsic functions which have a single named resource"""
    ret = name + "("
    for i, param in enumerate(values):
        if i > 0:
            ret += ", "
        # First parameter might be an object name or pseudo parameter
        if i == 0:
            ret += objects.lookup(param)
        else:
            ret += output_value(param)
    return ret + ")"


function_map = {
    'Fn::Base64': ("Base64", handle_no_objects),
    'Fn::And': ("And", handle_no_objects),
    'Fn::Or': ("Or", handle_no_objects),
    'Fn::Not': ("Not", handle_no_objects),
    'Fn::If': ("If", handle_one_object),
    'Fn::Equals': ("Equals", handle_no_objects),
    'Fn::FindInMap': ("FindInMap", handle_no_objects),
    'Fn::GetAtt': ("GetAtt", handle_one_object),
    'Fn::GetAZs': ("GetAZs", handle_no_objects),
    'Fn::Join': ("Join", handle_no_objects),
    'Fn::Select': ("Select", handle_one_object),
    'Ref': ("Ref", handle_one_object),
    'Condition': ("Condition", handle_one_object),
}


def output_value(v):
    """Output a value which may be a string or a set of function calls."""
    if isinstance(v, basestring):
        return '"%s"' % (v.replace('\\', '\\\\').replace('\n', '\\n').replace("\"", "\\\""))
    elif isinstance(v, bool):
        return '%s' % (str(v))
    elif isinstance(v, int):
        return '%d' % (v)
    elif isinstance(v, list):
        return "[" + ", ".join(map(output_value, v)) + "]"

    out = []
    # Should only be one of these...
    for fk, fv in v.items():
        if fk in function_map:
            (shortname, handler) = function_map[fk]
            if not isinstance(fv, list):
                fv = [fv]
            return handler(shortname, fv)
        else:
            out.append( '"' + fk + '": ' + output_value(fv))
    return "{ " + ", ".join(out) + " }"

def output_ref_value(v):
    """Output a value which may be a string or a set of function calls."""
    if type(v) == dict:
        for key, value in v.items():
            if key == "Ref":
                return "variables[\'" + value + "\'].ref"
            else:
                return output_value(v)

    else:
        return output_value(v)

def do_outputs(d):
    """Output the template Outputs"""
    global OUTPUTSPRESENT
    OUTPUTSPRESENT = 1
    blueprint.write('    def add_outputs(self):\n')
    blueprint.write('        t = self.template\n')
    outputs = d['Outputs']
    for k, v in outputs.items():
        blueprint.write('        %s = t.add_output(Output(\n' % (k,))
        blueprint.write('            "%s",\n' % (k, ))
        for pk, pv in v.items():
            if isinstance(pv, basestring):
                blueprint.write('            %s="%s",\n' % (pk, pv))
            else:
                blueprint.write('          %s=%s,\n' % (pk, output_value(pv)))
        blueprint.write('            ))\n')
        blueprint.write('\n')
        blueprint.write('\n')


def do_trailer(d):
    """Output a trailer section for the new Python script."""
    blueprint.write('    """ Below function is what is called by the '
                    'stacker build action """\n')
    blueprint.write('    def create_template(self):\n')
    if CONDITIONSPRESENT == 1:
        blueprint.write('        self.add_conditions()\n')
    if AWSTEMPLATEFORMATVERSIONPRESENT == 1:
        blueprint.write('        self.add_cfn_version()\n')
    if DESCRIPTIONPRESENT == 1:
        blueprint.write('        self.add_cfn_description()\n')
    if MAPPINGSPRESENT == 1:
        blueprint.write('        self.add_mappings()\n')
    blueprint.write('        self.add_resources()\n')
    if OUTPUTSPRESENT == 1:
        blueprint.write('        self.add_outputs()\n')



if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("template", help="json template to convert")
    parser.add_argument("blueprint", help="blueprint output to create. Used "
                        "for file name and class name in the blueprint")
    args = parser.parse_args()

    d = json.load(open(args.template))

    print d

    blueprint = open(args.blueprint, 'w+')

    do_header(d)
    do_classdefinition(d)
    sections = [
        #'Parameters',
        'Conditions',
        'AWSTemplateFormatVersion',
        'Description',
        'Mappings',
        'Resources',
        'Outputs',
    ]

    for s in sections:
        if s in d.keys():
            globals()["do_" + s.lower()](d)

    do_trailer(d)
